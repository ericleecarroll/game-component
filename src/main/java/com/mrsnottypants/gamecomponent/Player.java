package com.mrsnottypants.gamecomponent;

import java.util.*;

/**
 * Represents one player, either computer controlled or human.  Contains sets of play strategies by type.  This is how
 * computer controlled players weigh choices, but these can also be used to provide hints to human players.
 *
 * This is a flyweight class, meaning immutable with state externalized.
 * This allows for easy reuse without synchronization
 *
 * Created by Eric on 6/24/2016.
 */
public class Player {

    private final boolean computerControlled;
    private final Map<PlayStrategyType, Set<PlayStrategy>> playStrategies;

    /**
     * Construct a player
     * @param builder Player builder
     */
    private Player(Builder builder) {
        this.computerControlled = builder.computerControlled;
        this.playStrategies = builder.playStrategies;
    }

    /**
     * Return true if this is a computer controlled player
     * @return true if computer controlled
     */
    public boolean isComputerControlled() {
        return computerControlled;
    }

    /**
     * Return friendly string description
     * @return description
     */
    @Override
    public String toString() {
        return String.format("Player: Computer=%s, Strategies=%s",
                computerControlled, playStrategies.toString());
    }

    /**
     * Updates playChoice with choice values generated by relevant strategies.  For example: when picking a card to
     * play, card strategies update playChoice with entries assigning weights to each card in the player's hand - the
     * card with the highest weight is played.
     * @param type Type of choice being considered - picks relevant strategies
     * @param playerState State of the player
     * @param gameState State of the game
     * @param playChoice Updated with choice values
     */
    public void consider(PlayStrategyType type, PlayerState playerState, GameState gameState, PlayChoice playChoice) {

        // default to empty set
        Set<PlayStrategy> playStrategies = this.playStrategies.containsKey(type) ?
                this.playStrategies.get(type) : Collections.emptySet();

        // update playChoice with choices made by relevant strategies
        playStrategies.stream().forEach(strategy -> strategy.consider(playerState, gameState, playChoice));
    }

    // Used to build a player
    //
    public final static class Builder {

        private final boolean computerControlled;
        private final Map<PlayStrategyType, Set<PlayStrategy>> playStrategies = new HashMap<>();

        /**
         * Construct a player builder
         * @param computerControlled true if this is a computer controlled payer
         */
        public Builder(boolean computerControlled) {
            this.computerControlled = computerControlled;
        }

        /**
         * Add a play strategy to this player
         * @param type type of strategy, to which decisions does this strategy apply
         * @param playStrategy the strategy
         * @return builder, for easy chaining
         */
        public Builder addPlayStrategy(PlayStrategyType type, PlayStrategy playStrategy) {

            // add set for this type, if this is the first time we've seen this type
            if (!playStrategies.containsKey(type)) {
                playStrategies.put(type, new HashSet<>());
            }

            // save strategy by type
            playStrategies.get(type).add(playStrategy);
            return this;
        }


        /**
         * Construct and return a player
         * @return player
         */
        public Player build() {
            return new Player(this);
        }
    }
}
